

 1、缓存雪崩解决方案？
 (1)  缓存数据的过期时间设置随机，防止同一时间大数据过期现象发生。
 (2)  分布式部署缓存数据库，把热点数据均匀分布式在不同的缓存数据库中。
 (3)  设置热点数据永不过期。
 (4)  不同的key设置不同的过期时间，让缓存失效的时间点尽量保持均匀。
 (5)  使用缓存reload机制，预先去更新缓存，再把即将要发生大并发访问前手动触发加载缓存。
 (6)  做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1    缓存失效时间设置为短期，A2设置为长期。
 (7)  在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。

 2、缓存穿透解决方案?
(1)  接口层增加校验，如用户鉴权校验，id做基础校验，id<=0直接拦截。
(2)  对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。
(3)  缓存空对象，把null变成一个值。把空结果进行缓存，过期时间会比较短，最多不超过5分钟。
(4)  采用bloom filter布隆过滤器，把所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

 3、缓存击穿解决方案？
 (1) 简单分布式互斥锁。
 (2) "提前" 使用互斥锁。
 (3) 缓存设置永不过期。
 (4) 使用资源隔离组件hystrix。