

 1、缓存雪崩解决方案？
 (1)  缓存数据的过期时间设置随机，防止同一时间大数据过期现象发生。
 (2)  分布式部署缓存数据库，把热点数据均匀分布式在不同的缓存数据库中。
 (3)  设置热点数据永不过期。
 (4)  不同的key设置不同的过期时间，让缓存失效的时间点尽量保持均匀。
 (5)  使用缓存reload机制，预先去更新缓存，再把即将要发生大并发访问前手动触发加载缓存。
 (6)  做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1    缓存失效时间设置为短期，A2设置为长期。
 (7)  在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。

 2、缓存穿透解决方案?
(1)  接口层增加校验，如用户鉴权校验，id做基础校验，id<=0直接拦截。
(2)  对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。
(3)  缓存空对象，把null变成一个值。把空结果进行缓存，过期时间会比较短，最多不超过5分钟。
(4)  采用bloom filter布隆过滤器，把所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

 3、缓存击穿解决方案？
 (1) 简单分布式互斥锁。
 (2) "提前" 使用互斥锁。
 (3) 缓存设置永不过期。
 (4) 使用资源隔离组件hystrix。
 
 
 4、缓存算法
 
 FIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。
 LFU算法：Least Frequently Used，最不经常使用算法。
 LRU算法：Least Recently Used，近期最少使用算法。
 LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的。
 
  (1) FIFO算法：First  in First out ，先进先出。原则：宇哥数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据淘汰掉。
  (2) LFU算法：Least Frequently Used，最不经常使用的算法。
  (3) LRU算法：Least Recently Used，近期最少使用算法。
  备注：LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的。
 
 5、用redis实现分布式锁
      (1)主要使用的命令： 
              a;  setnx key val。当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。
              b;  expire key timeout。为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。
              c;  delete key。删除锁
      (2)实现思想： 
            a; 使用setnx加锁，如果返回1，则说明加锁成功，并设置超时时间，避免系统挂了，锁没法释        放。在finally中delete删除锁释放。
             b; 如果需要设置超时等待时间，则可以加个while循环，在获取不到锁的情况下，进行循环获取锁，超时了则退出。